#include "LightHelp.fx"

cbuffer Camera
{
  float4x4 mInvViewProj;
  float4x4 mInvView;
  float3 cameraPos;
  float padd;
};
cbuffer light
{
	DirLight dirLight;
};


//albedo RGBA, normalRGB_depthA, specular, worldPosition
Texture2D gBufferText[4] : register (t0);
SamplerState SampleTypeClamp : register(s0);

//-----------------------------------------------------------------------------------------
// Input and Output Structures
//-----------------------------------------------------------------------------------------

struct PSIn
{
	float4 Pos		: SV_Position;
	float2 TextCoord  : TEXCOORD; 

};
struct PSOut
{
	float4 LightMap : SV_TARGET0;
};

//-----------------------------------------------------------------------------------------
// PixelShader: PSSceneMain
//-----------------------------------------------------------------------------------------
//Phong Shader
float4 Phong(float3 Position, float3 N,float SpecularIntensity, float SpecularPower)
{

	//Calculate Reflection vector
	float3 R = normalize(reflect(dirLight.Direction.xyz, N));
	
	//Calculate Eye vector
	float3 E = normalize(cameraPos - Position.xyz);
	
	//Calculate N.L
	float NL = dot(N, - dirLight.Direction.xyz);

	//Calculate Diffuse
	float3 diffuse = NL * dirLight.Diffuse.xyz;
	
	//Calculate Specular 
	float Specular = SpecularIntensity * pow(saturate(dot(R, E)), SpecularPower);

	//Calculate Final Product
	return 2 * float4(diffuse.rgb, Specular); //LightIntensity
}

  //float4 ColorRGBA 				: SV_TARGET0;
  //float4 NormalRGB_DepthA 		: SV_TARGET1;
  //float4 AmbR_diffG_specB_powA 	: SV_TARGET2;
  //float4 PositionRGB_ 			: SV_TARGET3;
  
PSOut FPixelShader(PSIn input)
{	
	//albedo RGBA, normalRGB_depthA, specular, worldPosition
	PSOut output= ( PSOut )0;
	
	//sample albedo color
	float4 color = gBufferText[0].Sample( SampleTypeClamp, input.TextCoord);
	
	float3 normal  = gBufferText[1].Sample( SampleTypeClamp, input.TextCoord).xyz;
	normal = mul((2*normal -1),(float3x3)mInvView);
	
	float depth = gBufferText[1].Sample( SampleTypeClamp, input.TextCoord).w;

	//pos in homogenus clipspace
	float4 position = 1.0f;
	position.x = input.TextCoord.x * 2.0f - 1.0f;
	position.y = -(input.TextCoord.x * 2.0f - 1.0f);
	position.z = depth;
	
	position.xyz = gBufferText[3].Sample( SampleTypeClamp, input.TextCoord).xyz;
	
	//specular intensity
	float intens= gBufferText[2].Sample( SampleTypeClamp, input.TextCoord).r;
	
	
	//specular power
	float pow;
	pow = gBufferText[2].Sample( SampleTypeClamp, input.TextCoord).w;
	
	
	//pos in world space
	position = mul(position,mInvViewProj);
	position /= position.w;
	LightOutData finalLight;
	
	float4 LightColor  = Phong( position.xyz, normal, intens, pow);
	output.LightMap = clamp((LightColor*0.3) + (color*0.7), 0,1);
	
	//ComputeDirLight( dirLight, normal, cameraPos, finalLight);
	//output.LightMap = clamp((finalLight.Diffuse*0.3) + (color*0.7), 0,1);
	
	//-----------------------------
	/**
	float3 lightToPixel = -dirLight.Direction; //vector from the light source to the pixle
	
	float intensity		= dot(normalize(lightToPixel), normalize(normal.xyz));
	float4 lightColor		= dirLight.Ambient;

	if(intensity>0.0) //if light hits the pixle
	{
		lightColor+=dirLight.Diffuse * intensity;
	}
	output.LightMap 		= lightColor * 0.5 + color * 0.5; 	
	*/
	//--------------------------------------------
	
	//output.LightMap = LightColor; 
	
	
	return output;
}
