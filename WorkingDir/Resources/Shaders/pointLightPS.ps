#include "LightHelp.fx"

cbuffer Camera : register(b0)
{
  float4x4 mInvViewProj;
  float4x4 mInvView;
  float3 cameraPos;
  float padd;
};
cbuffer light : register(b1)
{
	PointLight pointLight;
};


//albedo RGBA, normalRGB_depthA, specular, worldPosition
Texture2D gBufferText[4] : register (t0);
SamplerState SampleTypeClamp : register(s0);

//-----------------------------------------------------------------------------------------
// Input and Output Structures
//-----------------------------------------------------------------------------------------

struct PS_IN
{
  float4 position 			: SV_POSITION;
  float4 ScreenPos 			: TEXCOORD;
};

struct PSOut
{
	float4 LightMap : SV_TARGET0;
};

//-----------------------------------------------------------------------------------------
// PixelShader: PSSceneMain
//-----------------------------------------------------------------------------------------
float ManualSample(float2 UV, int text)
{
	
	float w = 1200.0f;
	float h = 600.0f;

	
	float dx = 1.0f / w;
	
	float2 off[9] = 
	{
		float2(-dx, -dx ),	float2(0.0f, -dx ),	float2(dx, -dx),
		float2(-dx, 0.0f),	float2(0.0f, 0.0f),	float2(dx, 0.0f),
		float2(-dx, dx  ),	float2(0.0f, dx  ),	float2(dx, dx),
	};
	
	float4 color = 0.0f;
	for(int i = 0; i<9; i++)
	{
		color += gBufferText[text].Sample(SampleTypeClamp, UV + off[i]);
	}

	color /= 9;
	return color;

}

 //Phong Shader
float4 Phong(float3 Position, float3 N, float SpecularIntensity, float SpecularPower)
{
	//Calculate Light Vector
	float3 L = pointLight.Position.xyz - Position.xyz;
	
	//Calculate Linear Attenuation
	float Attenuation = saturate(1.0f - max(.01f, length(L)) / (pointLight.Position.w / 2 ));
	float intensity		= dot(normalize(L), normalize(N.xyz));
	float newIntensity	= ((pointLight.Position.w - length(L)) /pointLight.Position.w) * intensity;
	
	//Normalize Light Vector
	L = normalize(L);
	
	//Calculate Reflection vector
	float3 R = normalize(reflect( - L, N));

	//Calculate Eye vector
	float3 E = normalize(cameraPos -	Position.xyz);
	
	//Calculate N.L
	float NL = dot(N, L);
	
	//Calculate Diffuse 
	float3 Diffuse = NL * pointLight.Diffuse.xyz;
	
	//Calculate Specular
	SpecularIntensity = 0.6; 
	SpecularPower = 0.8;
	float Specular = SpecularIntensity * pow(saturate(dot(R, E)), SpecularPower);
	

	//Calculate Final Product
	float LightIntensity = 1.0;
	//return  LightIntensity* newIntensity *float4(Diffuse.rgb, 1);
	return  Attenuation *LightIntensity * float4(Diffuse.rgb, 1); //Specular);
}

  
  
  
PSOut FPixelShader(PS_IN input)
{	

	PSOut output= ( PSOut )0;
	float2 textPos;
	
	
	input.ScreenPos.xy /=  input.ScreenPos.w;
	float2 GBufferTextureSize = float2(1200,600);
	
	float2 UV = 0.5f * (float2(input.ScreenPos.x,- input.ScreenPos.y) + 1); // - float2(1.0f / GBufferTextureSize.xy);
	
	//sample albedo color
	float4 color = ManualSample(UV, 0);
	
	//normal already in world space
	float3 normal = ManualSample(UV, 1);
	normal = 2.0f* normal - 1;
	//normal = normalize(normal);
	//normal = mul(normal, mInvView);
	
	float depth = gBufferText[1].Sample( SampleTypeClamp, UV).a;
	
	// projected positions
	float4 position = float4(0,0,0,1);
	position.x = input.ScreenPos.x;
	position.y = input.ScreenPos.y;
	position.z = depth;
	
	//pos in world space
	position = mul(position,mInvViewProj);
	position /= position.w;
	
	//specular intensity
	float intens= gBufferText[2].Sample( SampleTypeClamp, UV).r;
	
	//specular power
	float pow = gBufferText[2].Sample( SampleTypeClamp, UV).w;
	
	float4 LightColor = float4(0,0,0,0);
	if(intens != 0) 
	{
		LightColor =  Phong(position, normal, intens, pow);
		LightColor.w = 1;
	}
	
	output.LightMap = LightColor;
	
	return output;
}
